# 8.9作业  
## 1.简述堆区和栈区的区别  
栈区（Stack）：内存由编译器自动分配和释放；随着函数调用创建，函数结束自动释放；储存的内容主要是局部变量，函数参数，返回地址等；空间较小；访问速度快，属于连续内存，不会产生内存碎片。  
堆区（Heap）：内存由程序员手动分配和释放（如利用`malloc``free`)，生命周期直到程序员释放或程序结束才释放；储存内容主要是动态分配的对象或数据；空间较大；访问速度比较慢（分配和访问需要额外的管理开销）；容易产生内存碎片。  
## 2.简述出现野指针的可能原因和相应的避免方法
野指针是指向不明确内存地址的指针，可能会导致程序崩溃或数据错误。他的本质是一个未初始化或者已经失效的指针变量。  
### 出现原因
1.指针未初始化  
2.指针指向的内存已释放  
3.指针越界访问  
返回局部变量地址  
### 避免野指针的方法  
1.声明指针时初始化为NULL  
2.释放内存后将指针置为NULL  
3.避免返回局部变量地址  
4.严格控制数组和指针的边界  
5.使用工具如`ASan`检测  
## 3.分析该程序运行后的输出结果。
```  
int main()
 {
    int arr[5] = { 1, 2, 3, 4, 5};
    int* ptr1 = (int*)(&arr + 0x1);
    int* ptr2 = (int*)((int)arr + 0x1);
    printf("%x,%x", ptr1[-1], *ptr2);
    return 0;
 }
```  
`0x1`表示十六进制中的1，`arr`表示指向数组第0个元素的指针，类型为`int *`，`&arr`是数组的整体地址，类型为`int (*)[5]`  
`&arr + 1`表示跳过一个`int[5]`的大小，也就是地址`arr` +`sizeof(int[5])`,所以`(int *)(&arr + 0x1)`转换后得到的`int *`指向数组末尾的后一个地址,相当于`&a[5]`  
`ptr1[-1]`即为`a[4]`=5的十六进制形式  
`(int)arr`将指针强转为`int`，再将这个数值+1；之后再转换为`int*`，相当于将数组起始位置地址偏移一个字节后当成整形指针。结果通常不是按`int`对齐。把一个非对齐地址当`int *`解引用是未定义行为，这样得到的`ptr2`指向的是“从第一个字节开始读4字节”的位置，会把不同元素的字节拼在一起，读出来的值跟先前不同。  
## 4.我们可以用#define定义常量，为什么要用枚举？  
`define`的处理是在预处理器直接文本替换，没有数据类型，调试时调试器里看不到名字，只看到替换后的值，作用域是全局。  
`enum`的处理是编译器在编译期分配常量值，有明确的类型，通常是`int`，调试器中可以看到枚举常量的名字和值，是真正的常量表达式。  
`enum`：类型安全、作用域可控、调试友好、可自动递增，推荐用来定义一组相关的常量值（特别是状态码、颜色、事件类型等）。  
`#define`：只是文本替换，没有类型信息，调试体验差，更容易出错，但在预处理器层面或条件编译中有用。
